---
alwaysApply: false
---

# Cloudflare Agents SDK Best Practices

This document outlines the best practices and critical requirements for using the Cloudflare Agents SDK within the 9to5 Scout project. Adhering to these guidelines ensures consistent, type-safe, and performant AI agent implementations.

## Critical Agents SDK Requirements

- **ALWAYS** use the official `agents` package from npm: `npm i agents` or `pnpm add agents`
- **NEVER** create local agent implementations or import from local files
- **ALWAYS** extend the `Agent` class from the `agents` package
- **ALWAYS** use proper TypeScript typing with `Agent<Env, State>`
- **ALWAYS** configure Durable Object bindings in `wrangler.toml` or `wrangler.jsonc`
- **ALWAYS** include SQLite migrations for agent state storage

## Package Installation

```bash
# CORRECT - Use official package
pnpm add agents

# WRONG - Don't create local implementations
# import { Agent } from "./agents"; // ❌
```

## Agent Class Implementation

### ✅ Correct Agent Implementation

```typescript
import { Agent, Connection, ConnectionContext, WSMessage } from "agents";

interface Env {
  DB: D1Database;
  AI: Ai;
  MY_AGENT: DurableObjectNamespace;
}

interface AgentState {
  currentAgent: string | null;
  sessionId: string | null;
  lastActivity: number;
  conversationHistory: Array<{
    role: "user" | "assistant" | "system";
    content: string;
    timestamp: number;
  }>;
}

export class MyAgent extends Agent<Env, AgentState> {
  // Initial state definition
  initialState: AgentState = {
    currentAgent: null,
    sessionId: null,
    lastActivity: Date.now(),
    conversationHistory: [],
  };

  // Called when Agent starts or wakes from hibernation
  async onStart() {
    console.log("Agent started with state:", this.state);
  }

  // Handle HTTP requests
  async onRequest(request: Request): Promise<Response> {
    return new Response("Hello from Agent!");
  }

  // Handle WebSocket connections
  async onConnect(connection: Connection, ctx: ConnectionContext) {
    console.log("WebSocket connection established:", connection.id);
  }

  // Handle WebSocket messages
  async onMessage(connection: Connection, message: WSMessage) {
    // Handle incoming messages
    connection.send("Received your message");
  }

  // Handle WebSocket errors
  async onError(connection: Connection, error: unknown): Promise<void> {
    console.error(`Connection error:`, error);
  }

  // Handle WebSocket close events
  async onClose(
    connection: Connection,
    code: number,
    reason: string,
    wasClean: boolean
  ): Promise<void> {
    console.log(`Connection closed: ${code} - ${reason}`);
  }

  // State update handler
  onStateUpdate(state: AgentState, source: "server" | Connection) {
    console.log("State updated:", state, "Source:", source);
  }

  // Custom methods
  async customMethod(data: any) {
    this.setState({ ...this.state, lastUpdated: new Date() });
  }
}
```

### ❌ Incorrect Agent Implementation (Avoid)

```typescript
// WRONG - Don't import from local files
import { Agent } from "./agents"; // ❌

// WRONG - Don't use any types
class MyAgent extends Agent<any, any> { // ❌

// WRONG - Don't use deprecated WebSocket methods
async onWebSocket(ws: WebSocket, request: Request) { // ❌
```

## Configuration Requirements

### wrangler.toml Configuration

```toml
[[durable_objects.bindings]]
name = "MY_AGENT"
class_name = "MyAgent"

[[migrations]]
tag = "v1"
new_sqlite_classes = ["MyAgent"]
```

### wrangler.jsonc Configuration

```jsonc
{
  "durable_objects": {
    "bindings": [
      {
        "name": "MY_AGENT",
        "class_name": "MyAgent"
      }
    ]
  },
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": ["MyAgent"]
    }
  ]
}
```

## State Management

### Using setState

```typescript
// Update agent state
this.setState({
  ...this.state,
  lastActivity: Date.now(),
  newProperty: "value",
});

// State is automatically persisted and synced to connected clients
```

### State Synchronization

```typescript
// Clients automatically receive state updates
onStateUpdate(state: AgentState, source: "server" | Connection) {
  console.log("State updated:", state);
  // Notify connected clients, update UI, etc.
}
```

## WebSocket Communication

### Server-Side (Agent)

```typescript
async onMessage(connection: Connection, message: WSMessage) {
  const data = JSON.parse(message as string);

  // Process message
  const response = await this.processMessage(data);

  // Send response back to client
  connection.send(JSON.stringify({
    type: "response",
    data: response,
    timestamp: Date.now()
  }));
}
```

### Client-Side (Browser)

```typescript
import { AgentClient } from "agents/client";

const connection = new AgentClient({
  agent: "my-agent",
  name: "user-session-123",
});

connection.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log("Received:", data);
};

// Send message to agent
connection.send(
  JSON.stringify({
    type: "message",
    content: "Hello agent!",
  })
);
```

## AI Model Integration

### Using Workers AI with Agents

```typescript
// Correct AI model usage in agents
async processWithAI(prompt: string) {
  const response = await this.env.AI.run(
    this.env.DEFAULT_MODEL_REASONING as keyof AiModels,
    {
      messages: [{ role: "user", content: prompt }],
      max_tokens: 1000,
      temperature: 0.7
    }
  );

  return response;
}
```

## Error Handling

### Proper Error Handling

```typescript
async onRequest(request: Request): Promise<Response> {
  try {
    // Agent logic
    return new Response(JSON.stringify({ success: true }));
  } catch (error) {
    console.error("Agent error:", error);
    return new Response(
      JSON.stringify({
        error: error instanceof Error ? error.message : String(error)
      }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
}
```

## Testing and Development

### Local Development

```bash
# Install dependencies
pnpm add agents

# Generate types
pnpm exec wrangler types

# Run locally
pnpm exec wrangler dev
```

### Deployment

```bash
# Deploy agent
pnpm exec wrangler deploy
```

## Common Patterns

### Generic Agent Pattern

```typescript
export class GenericAgent extends Agent<Env, AgentState> {
  async runAgent(agentName: string, prompt: string, sessionId?: string) {
    // Load configuration from database
    const config = await this.getAgentConfig(agentName);

    // Execute AI task
    const response = await this.env.AI.run(config.llm as keyof AiModels, {
      messages: [{ role: "user", content: prompt }],
    });

    // Update state
    this.setState({
      ...this.state,
      currentAgent: agentName,
      lastActivity: Date.now(),
    });

    return response;
  }
}
```

## Verification Checklist

- [ ] `agents` package installed via pnpm
- [ ] Agent class extends `Agent<Env, State>`
- [ ] Proper TypeScript typing throughout
- [ ] Durable Object binding configured in wrangler.toml/jsonc
- [ ] SQLite migration includes agent class name
- [ ] WebSocket methods use correct signatures
- [ ] State management uses `this.setState()`
- [ ] Error handling implemented
- [ ] AI model calls use proper typing

## Resources

- [Cloudflare Agents Documentation](https://developers.cloudflare.com/agents/)
- [Agents API Reference](https://developers.cloudflare.com/agents/api-reference/)
- [Durable Objects Configuration](https://developers.cloudflare.com/durable-objects/get-started/)
- [WebSocket API Reference](https://developers.cloudflare.com/agents/api-reference/websockets/)

# Cloudflare Agents SDK Best Practices

This document outlines the best practices and critical requirements for using the Cloudflare Agents SDK within the 9to5 Scout project. Adhering to these guidelines ensures consistent, type-safe, and performant AI agent implementations.

## Critical Agents SDK Requirements

- **ALWAYS** use the official `agents` package from npm: `npm i agents` or `pnpm add agents`
- **NEVER** create local agent implementations or import from local files
- **ALWAYS** extend the `Agent` class from the `agents` package
- **ALWAYS** use proper TypeScript typing with `Agent<Env, State>`
- **ALWAYS** configure Durable Object bindings in `wrangler.toml` or `wrangler.jsonc`
- **ALWAYS** include SQLite migrations for agent state storage

## Package Installation

```bash
# CORRECT - Use official package
pnpm add agents

# WRONG - Don't create local implementations
# import { Agent } from "./agents"; // ❌
```

## Agent Class Implementation

### ✅ Correct Agent Implementation

```typescript
import { Agent, Connection, ConnectionContext, WSMessage } from "agents";

interface Env {
  DB: D1Database;
  AI: Ai;
  MY_AGENT: DurableObjectNamespace;
}

interface AgentState {
  currentAgent: string | null;
  sessionId: string | null;
  lastActivity: number;
  conversationHistory: Array<{
    role: "user" | "assistant" | "system";
    content: string;
    timestamp: number;
  }>;
}

export class MyAgent extends Agent<Env, AgentState> {
  // Initial state definition
  initialState: AgentState = {
    currentAgent: null,
    sessionId: null,
    lastActivity: Date.now(),
    conversationHistory: [],
  };

  // Called when Agent starts or wakes from hibernation
  async onStart() {
    console.log("Agent started with state:", this.state);
  }

  // Handle HTTP requests
  async onRequest(request: Request): Promise<Response> {
    return new Response("Hello from Agent!");
  }

  // Handle WebSocket connections
  async onConnect(connection: Connection, ctx: ConnectionContext) {
    console.log("WebSocket connection established:", connection.id);
  }

  // Handle WebSocket messages
  async onMessage(connection: Connection, message: WSMessage) {
    // Handle incoming messages
    connection.send("Received your message");
  }

  // Handle WebSocket errors
  async onError(connection: Connection, error: unknown): Promise<void> {
    console.error(`Connection error:`, error);
  }

  // Handle WebSocket close events
  async onClose(
    connection: Connection,
    code: number,
    reason: string,
    wasClean: boolean
  ): Promise<void> {
    console.log(`Connection closed: ${code} - ${reason}`);
  }

  // State update handler
  onStateUpdate(state: AgentState, source: "server" | Connection) {
    console.log("State updated:", state, "Source:", source);
  }

  // Custom methods
  async customMethod(data: any) {
    this.setState({ ...this.state, lastUpdated: new Date() });
  }
}
```

### ❌ Incorrect Agent Implementation (Avoid)

```typescript
// WRONG - Don't import from local files
import { Agent } from "./agents"; // ❌

// WRONG - Don't use any types
class MyAgent extends Agent<any, any> { // ❌

// WRONG - Don't use deprecated WebSocket methods
async onWebSocket(ws: WebSocket, request: Request) { // ❌
```

## Configuration Requirements

### wrangler.toml Configuration

```toml
[[durable_objects.bindings]]
name = "MY_AGENT"
class_name = "MyAgent"

[[migrations]]
tag = "v1"
new_sqlite_classes = ["MyAgent"]
```

### wrangler.jsonc Configuration

```jsonc
{
  "durable_objects": {
    "bindings": [
      {
        "name": "MY_AGENT",
        "class_name": "MyAgent"
      }
    ]
  },
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": ["MyAgent"]
    }
  ]
}
```

## State Management

### Using setState

```typescript
// Update agent state
this.setState({
  ...this.state,
  lastActivity: Date.now(),
  newProperty: "value",
});

// State is automatically persisted and synced to connected clients
```

### State Synchronization

```typescript
// Clients automatically receive state updates
onStateUpdate(state: AgentState, source: "server" | Connection) {
  console.log("State updated:", state);
  // Notify connected clients, update UI, etc.
}
```

## WebSocket Communication

### Server-Side (Agent)

```typescript
async onMessage(connection: Connection, message: WSMessage) {
  const data = JSON.parse(message as string);

  // Process message
  const response = await this.processMessage(data);

  // Send response back to client
  connection.send(JSON.stringify({
    type: "response",
    data: response,
    timestamp: Date.now()
  }));
}
```

### Client-Side (Browser)

```typescript
import { AgentClient } from "agents/client";

const connection = new AgentClient({
  agent: "my-agent",
  name: "user-session-123",
});

connection.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log("Received:", data);
};

// Send message to agent
connection.send(
  JSON.stringify({
    type: "message",
    content: "Hello agent!",
  })
);
```

## AI Model Integration

### Using Workers AI with Agents

```typescript
// Correct AI model usage in agents
async processWithAI(prompt: string) {
  const response = await this.env.AI.run(
    this.env.DEFAULT_MODEL_REASONING as keyof AiModels,
    {
      messages: [{ role: "user", content: prompt }],
      max_tokens: 1000,
      temperature: 0.7
    }
  );

  return response;
}
```

## Error Handling

### Proper Error Handling

```typescript
async onRequest(request: Request): Promise<Response> {
  try {
    // Agent logic
    return new Response(JSON.stringify({ success: true }));
  } catch (error) {
    console.error("Agent error:", error);
    return new Response(
      JSON.stringify({
        error: error instanceof Error ? error.message : String(error)
      }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
}
```

## Testing and Development

### Local Development

```bash
# Install dependencies
pnpm add agents

# Generate types
pnpm exec wrangler types

# Run locally
pnpm exec wrangler dev
```

### Deployment

```bash
# Deploy agent
pnpm exec wrangler deploy
```

## Common Patterns

### Generic Agent Pattern

```typescript
export class GenericAgent extends Agent<Env, AgentState> {
  async runAgent(agentName: string, prompt: string, sessionId?: string) {
    // Load configuration from database
    const config = await this.getAgentConfig(agentName);

    // Execute AI task
    const response = await this.env.AI.run(config.llm as keyof AiModels, {
      messages: [{ role: "user", content: prompt }],
    });

    // Update state
    this.setState({
      ...this.state,
      currentAgent: agentName,
      lastActivity: Date.now(),
    });

    return response;
  }
}
```

## Verification Checklist

- [ ] `agents` package installed via pnpm
- [ ] Agent class extends `Agent<Env, State>`
- [ ] Proper TypeScript typing throughout
- [ ] Durable Object binding configured in wrangler.toml/jsonc
- [ ] SQLite migration includes agent class name
- [ ] WebSocket methods use correct signatures
- [ ] State management uses `this.setState()`
- [ ] Error handling implemented
- [ ] AI model calls use proper typing

## Resources

- [Cloudflare Agents Documentation](https://developers.cloudflare.com/agents/)
- [Agents API Reference](https://developers.cloudflare.com/agents/api-reference/)
- [Durable Objects Configuration](https://developers.cloudflare.com/durable-objects/get-started/)
- [WebSocket API Reference](https://developers.cloudflare.com/agents/api-reference/websockets/)
